### http请求头，请求体，cookie， url在哪？
http请求包括：
  请求行：请求方法，url， 协议版本 
  请求头：user-agent发出请求的用户信息， Accept指定客户端接受哪些类型的信息，cookie身份凭证
  请求数据

http响应包括：
  状态行，http-version,http协议版本，status-code状态码，reason-phrase状态码的文本描述
  消息报头：日期，content-type，content-length
  空行，
  响应正文<html><head><title>我是title</title></head></html>

    HTTP/1.1 200 OK
    Date: .....
    Server: Apache
    Last-Modified: ....
    ETag: '...'
    Accept-Ranges: bytes
    Content-length:51
    Content-type: text/plain

### OSI模型
  应用层：一般是我们编写的应用程序，决定了向用户提供的服务，应用层可以通过系统调用与传输层进行通信，比如FTP、DNS、HTTP等
  表示层: 协商数据格式化，代码转换，数据加密，没有协议
  会话层： 解除或建立与别的节点联系，没有协议
  传输层：通过系统调用向应用层提供处于网络连接中的两台计算机之间的数据传输功能（TCP/UDP）（TCP要建立连接所以效率低
  网络层：用来处理在网络上流动的数据包，该层规定了通过怎样的路径（传输路线）到达对方计算机，并把数据包传输给对方
  数据链路层：负责网址寻址、错误侦测和改错，处理连接网络的硬件部分，包括控制操作系统、硬件设备驱动，网卡等
  物理层：在局部局域网中传送数据帧，负责计算机通信和网络媒体之间的互通

###  数据包的封装
  应用程序数据在发布到数据网络之前，每层协议都在上层协议基础上加上自己的头部信息，链路层还会加上一个尾部
  Http数据传输过程：
      发送数据：数据从上到下，且每经过一层都会被打上该层的头部信息
      接收数据：数据从下往上，传输前会把下层的头部信息删除
  作为发送端的客户端在应用层（通过Http协议发送一个请求），为了传输方便，在传输层（通过Tcp协议将应用层收到的数据，也就是报文进行分割，在各个报文打上标记序号，端口号等等一系列信息发送到网络层，网络层通过Ip协议增加作为通讯目的地的Mac地址，然后转发给链路层，接收端的服务端在数据链路层接收到请求数据，按顺序向上传递


### SQL注入
主要是针对数据库的，几乎每个web应用都要用数据库操作所需各种信息，用户提交数据的SQL语句不安全，容易收到SQL注入的攻击
SQL注入危害：
    探知数据库的具体结果，为进一步攻击做准备
    泄露数据，尤其是机密信息
    取得更高权限，来修改表数据甚至内部结构
    如家CSDN密码泄露，
SQL注入防御：
    参数化查询：根本性的防御策略，也叫预处理语句，在建立一个包含用户输入SQL语句时分两步：
                1：指定查询结构，用户输入预留占位符
                2：指定占位符的内容
### XSS攻击原理 Cross Site Scripting 跨站脚本攻击，
将恶意代码植入到其他用户页面，其他用户在观看网页时候，恶意脚本就会执行。 通常通过注入HTML或js等脚本发起攻击（比如做个假的登陆界面） 攻击成功后，攻击者可以得到私密网页内容和Cookie等 
XSS攻击危害 
  盗取各类用户账号 控制数据，包括读取，篡改，添加删除企业敏感数据的能力 
  非法转账 控制受害者机器向其他网站发起攻击 
XSS案例： 
  Myspace事件：存储式XSS攻击 2005年，一名叫samy的用户发现Myspace的XSS漏洞，他在用户资料页面插入了一些javascript脚本，如果谁查看了他的用户资料，脚本就执行，一加samy好友，2：将脚本复制到受害者自己的用户资料页面中。Myspace被迫关站。 
  Apache事件：反射式XSS攻击 

XSS分类：
    反射式XSS：
        发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。
        是目前最流行的XSS攻击，她出现在服务器没有对数据进行无害化处理。如果提交的数据中含有html控制字符而没有被正确处理，那么XSS攻击会发生。典型的反射式攻击可通过一个邮件或者中间网站，诱饵是一个看起来吸引人的站点的连接，其中包含XSS攻击脚本，如果信任的网站没有正确处理这个脚本，用户点击后就会导致浏览器执行含有恶意攻击的脚本。
    存储式XSS：
        提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码
        永久性XSS，危害更大，不是最流行（非常容易留下痕迹，容易被清除）
    基于DOM的XSS攻击：
        DOM XSS的代码并不需要服务器参与，触发XSS靠的是浏览器端的DOM解析，完全是客户端的事情。
        反射性XSS攻击和存储式XSS攻击都是通过服务端提取用户提交的数据，并且以不安全的方式将其返回给用户。基于DOM的攻击仅仅在前端通过js方式执行。
XSS可能会攻击的地方）
    1：会话令牌，XSS攻击最普遍的方式。
    2：虚拟置换，这种攻击要在一个Web应用程序页面注入恶意数据，包括简单的向站点注入html，或者使用脚本注入精心设计的内容。
    3：注入木马，这种攻击造成的后果远比虚拟置换严重，如：弹出框告诉你用户信息登录失效重新登录。
XSS防御措施：
    1：输入验证，若程序在某个位置收到用户提交的数据将来可能会被复制到其他响应中，程序根据这种情形对这些数据执行尽可能严格的确认（数据不是太长，数据仅包含某组合法字符，数据与一个特殊字符的正规表达式相匹配）。
    2：输出编码，若程序将某位用户或第三方提交的数据复制到他的响应中，那么程序应该对这些数据进行html编码，以净化可能的恶意字符。
    html编码指用对应的html实体代替字面量字符，这样做可确保浏览器安全处理可能为恶意的字符，把他们当作html文档的内容而非结构处理。
    两层防御程序能够获得额外的保护。输出确认最为重要，必不可少
### CSRF（Cross-site Request Forgery）跨站请求伪造，也叫XSRF， 
攻击方式：如通过电子邮件发送一个链接来蛊惑受害者进行一些敏感性的操作，如修改密码，修改E-mail，转账等。 
危害： 破坏力依赖于受害者的权限。如果有管理员权限，会威胁到整个网站的安全。 
与XSS相比，XSRF攻击不太流行，难以防范 被认为比XSS更具危险性，
典型的CSRF攻击： A登录了一个金融网站，B发现这个网站的转账功能有CSRF漏洞，B在该网站发布了一条blog，这个blog支持img自定义功能，所以B插入了一行html代码 A在自己浏览器打开了另一个页面，A的账户向B转了3000却不知道。 

CSRF攻击防御 1：增加一些确认操作，比如弹出框“你确认转账？” 
            2：重新认证，做些敏感操作时，要求用户重新输入密码二次验证
            3：使用Token，在用户刚登陆的时候，产生一个新的不可阈值的CSRFToken，并且把此Token存放在用户的session中。在任何一个需要保护的表单中，增加一个隐藏字段来存放Token。提交此请求时服务端检查提交的Token和用户Session中的Token是否一致，不一致返回错误。在用户退出或者session过期，用户信息从session中移除并且销毁session

### 列举三种禁止浏览器缓存的头字段，并写出响应的设置值
catch-control: no-cache
catch-control：max-age=0
expires：告诉浏览器资源失效的时间

### http特点
1）支持客户/服务器模式（由客户端发出请求）
2）简单快速，只要传送请求方法/路径（由于http协议简单，使得http服务器的程序规模小，因而通信速度很快 
3）灵活，http允许传输任意类型数据对象，由content-type加以标记（1.0后） 
4）无连接，每次连接只处理一个请求，服务器处理完客户端请求，并接收到客户端答应之后，就断开连接，采用这种方式可以节约时间。（keep-alive：让客户端与服务端的连接持续有效，避免重新建立连接） keep-alive就是将多个HTTP请求合并成一个
5）无状态：协议对事务处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，导致每次传输数据很大

###  为什么Http要基于TCP
TCP是一种端到端的可靠的面向链接的协议，http基于传输层tcp协议不用担心数据传输的各种问题（发生错误会重传）

### SPDY
谷歌提出，为了最小化网络延迟，提升网络速度，对http的增强，
http： http+tcp+ip
SPDY：http+tcp+ip+spdy+TLS
1）多路复用：允许一个连接可以有无限个并行请求，还可以设置优先级，防止非重要资源占用通道
2）支持服务器推送
3）spdy压缩了http的header，舍去了不必要的头部信息
4）强制使用SSL，对用户来说网页速度变快，不担心数据被截取
类似websocket但是已经不再维护，由http2替代

webRTC用于流数据，直播流

### http和https的区别
http： 通过明文传输不安全,

https： 安全，要申请证书，在http基础上增加了一层安全层，一系列的加密操作都是在安全层进行的。https可认为是http+TLS，
      TLS是传输层加密协议，前身是SSL，SSL是https建立在应用层和传输层，TCP协议之上的一个加密通道。
      HTTPS增加了3个强大的功能对付劫持行为：1）内容加密 2）身份认证，数字证书。 3）数据完整性

https的证书颁发过程：1： 生成服务端证书签名： 服务端将公钥key1发送证书机构，机构用自己私钥加密key1，根据服务端网址等信息生成经过私钥加密的证书签名。 
                  2： 客户端解密证书签名：  服务度将证书签名发送到客户端，客户端只要知道是哪家证书颁发机构的签名就能从本地找到找到机构公钥解密证书签名。
                  3： 客户端生成证书签名： 客户端用同样方式生成自己的证书签名，如果两个证书签名一致说明有效。
                  4： 客户端生成对策加密秘钥： 客户端用公钥解密服务端的公钥key1，
                  5： 服务端解密： 客户端生成对称加密秘钥key2，用服务端公钥key1加密key2，发送到服务端，服务端用自己私钥解密

### http1.0和http2.0有哪些区别
http1.0：一次性连接
http1.1：保持连接，性能提升
http2.0：强制https，自带双向通信，多路复用

http2.0核心：二进制分针，在不改变http语义，状态码，方法，utI，首部字段等等核心概念下，做出了突破http1.1标准的性能限制，实现低延迟高吞吐量。
            2）之所以叫2.0就是因为增加了二进制分帧。 将所有的传输信息分割成更小的消息和帧，并且采用二进制形式编码。
            3）http2.0首部压缩：首部表跟踪/存储之前发送键值对，相同的不再通过每次请求和响应发送。其实就是只发送发生变化的字段。通信双方缓存了一份首部表，即避免了重复header的传输。 
            4）http2.0多路复用： 继承SPDY协议，所有通信都在一个TCP连接中完成。2.0把http基本单位缩小为帧。TCP性能：关键在于低延迟，大部分TCP连接很短，突发性。TCP只在长时间传输连接，传输大文件的时候效率才最高。

HTTP2.0的问题：还是底层支称的TCP造成的， 
          1：队头阻塞（当连接中出现丢包，2.0不如1，丢包之后整个tcp都要等待重传，导致后面数据被阻塞，对于http1.1来说，开启多个tcp连接，出现这个问题只会影响单个连接。） 
          2：建立连接的握手延迟：不管是1.0还是1.1，https都是tcp进行传输，https，2.0还要使用TLS进行安全传输，这样出现两个握手延迟。TLS完全握手至少需要RTT两回才能建立，对于短连接来说，这个延迟影响很大无法消除。 QUIC是TCP遗留的无法解决问题的优化。 针对延迟问题：0 RTT ：QUIC利用类似TCP快速打开的技术，缓存当前会话上下文，下次恢复会话时候只要将会话缓存传到服务器确认，确认通过就可以进行传输。 传统TCP：客户端————服务端————响应客户端（1RTT）————客户端发送ACK+SYN————服务端响应（2RTT） TCP+TLS：4RTT QUIC：2RTT


### tcp/udp区别
连接方面：tcp面向连接，udp无连接
安全方面：tcp提供可靠服务，udp尽最大努力交付
传输效率方面：tcp传输效率低，udp传输效率高，适用对于高速传输和实时性传输有较高的通信或广播通信
连接对象数量的区别：tcp点到点，一对一，udp一对一，一对多，多对一

### tcp三次握手过程
    1：客户端发送带有SYN标识（SYN=1，seq=x）的连接请求报文段，然后进入SYN_SEND状态，等待服务端确认。
    2：服务端接收到客户端SYN报文段后，需要发送ACK信息对这个SYN进行确认，同时还要发送自己的SYN信息（SYN=1，ACK=1，seq=y，ack=x+1）服务端把这些信息放在一个报文段中（（SYN+ACK报文段），一并发给客户端，此时服务端进入SYN_RECV状态
    3：客户端接收到服务端的SYN+ACK报文段后会向服务端发送ACK（ACK=1，seq=x+1，ack=y+1）确认报文段，这个报文段发送后， 客户端和服务端都进入ESTABLISHED状态，完成三次握手。
    三次？双方要明确对方接收能力都是正常的，（客户端发之后，服务端可以确定客户端有发送能力，服务端发送给客户端，可以确定服务端的接收和发送能力正常，最后客户端发送确认，来确定客户端的接受能力

### Http结构
请求头：
  1: method:方法,
  2: url:路径,
  3: 协议，
  4: content-type: 请求内容数据类型，
  5： host：请求资源所在服务器，
  6： cookie，
  7： connection：keep-alive/close，控制连接,
  8： cache-control：控制缓存,
  9； Date： 创建日期,
  10：If-none-Match,和上次资源对比是否改变
  11：If-modifed-since，
  12：user-egent：代理
  13：Accept：用户代理可处理的媒体类型，如text/html
  14：Accept-laguage：优先语言
  15：Accept-chartset：优先字符集
  16：Accept-encoading:优先内容编码
  17：x-requested-with： XMLHttpRequest
  18：expires

响应头: 
  1： status：状态码，
  2： 协议版本，
  3： cache-control，
  4： set-cookie，
  5： content-Type， 
  6： Date ,
  7： Etag， 
  8： content-length
  9： age：资源创建经历的时间
  10： location：领客户端重定向的URI
  11： last-modified


### http请求方式
http1.0中有三种请求方式：get，post，head
http1.1新增5种请求方式： put，delete，connect，trace，options
1）get，请求参数拼接在地址后面，安全性低，浏览器对url有限制，所以体积不能大，将header和data一起发出去
2）post，请求参数放在请求体，安全性相对高，发送两个数据包，第一次发送header响应100continue，第二次带上请求参数发送请求，请求体积不限（表面上看get比post高效率，网速好的情况下，发送一个数据包和2个时差基本没有区别，无视网络环境差时，2次包
3）put，和post不同，put是幂等的，没有验证机制，更多时间用put来传输资源。put更新服务器已经有的数据(覆盖修改)
4）head，和get类似，只返回请求头
5）delete，请求删除资源服务器某些资源
6）options：获取指定的资源能够支持的请求方式，获取服务器支持的请求方式，2：检查服务器性能，发起一个预检请求获取是否支持跨域请求。需预检的请求必须发起options请求再发正常请求。
7）trace：回显服务端收到的请求，主要用于测试或者诊断，客户端发送trace请求来获取发出去的请求是怎样被篡改的，
8）connect：开启客户端和所请求资源之间双向沟通的通道，可以用来创建隧道，http代理的时候用connect请求
9）patch：增量修改资源

post请求变成options请求导致404解决办法：axios.default.header['Content-Type']='application/x-www-urlencoded;charset=utf-8'

预检请求是CORS中一种透明服务器验证机制。预检请求首先需要向另外一个域名资源发送一个 OPTIONS 请求头，目的就是为了判断实际发送的请求是否是安全的。
简单请求不会发起预检请求：
1：请求方式为get，post，head中的一种
2：请求头类型是Accepted，Accept-language，content-language，content-type多了就不是简单请求了
3：content-type为application/x-www-form-urlencoded, text/plain, multipart/form-data,
4: 请求中任意XMLHttpRequestUpload对象均没有注册任何事件监听器
5：请求中没有使用readableStream对象
cors本质是使用各种头信息对浏览器和服务器之间进行身份认证实现跨域资源共享
### http身份认证有哪些方法？
1）basic认证：http1.0，客户端请求，服务端返回401，用户携带经过base64编码的用户名密码到首部字段（Authorization）到服务端，成功200，失败401.base64不是加密不安全
2）digest认证：http1.1，弥补basic认证，服务端返回401和临时质询码，不发送明文，客户端响应包含经过h5加密的digest字段，但是防止不了用户伪装
3）SSL客户端认证：借用https客户端证书来完成认证，服务端通过证书判断用户是否来自自己登陆的用户。收到需要认证的用户请求，服务端会要求客户端提供证书，客户端提供证书后，服务端验证，通过：获取客户端证书内容的秘钥，开启https加密通信，一般银行用。要一定成本
4）表单认证：由web应用基于表单实现的认证方式，通过cookie和session来保持用户状态。

### DNS
1：DNS：把域名和ip地址相互映射分布式数据库，DNS协议运行在UDP协议之上。 
2：DNS解析：通过域名最终得到对应ip地址的过程。 
3：DNS缓存：浏览器，操作系统，LocalDNS，根域名服务器都会对DNS结果作出一定的缓存 
4：DNS查询过程：先搜索浏览器自身DNS缓存=》读取操作系统的hosts文件看是否存在对应的映射关系=》TCP/IP参数里设置的首选DNS服务器=》根服务器发出请求，进行递归查询

CDN：内容分发网络，缓存服务器，为买票者提供了方便，帮助他们在最近的CDN节点，最短的请求时间，拿到资源，起到分流作用，减轻服务器负载压力
CDN缓存：在浏览器本地缓存失效后，浏览器会像CDN边缘节点发起请求，类似浏览器缓存，CDN边缘节点也存在一套缓存机制，CDN边缘节点缓存策略因服务商不同而不同，通过http响应头中的cache-control：max-age字段设置CDN边缘节点数据缓存时间。 当浏览器向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据过期，CDN会像服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端，CDN服务商一般会提供基于文件后缀，目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。 
CDN优势： 1：CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低 2：大部分请求在CDN边缘节点完成，CDN起到分流作用，减轻了源服务器的负载。

CDN工作方式： 当你点击网站页面的url时，经过本地域名系统解析，域名系统解析会最终把域名的解析权交给cname()指向的内容分发专用的域名系统服务器。

内容分发的域名系统服务器把内容分发的全局负载均衡设备ip地址返回给用户。

当你像内容分发的全局负载均衡设备发起url访问请求，内容分发网络的全局负载均衡设备会为你选择一台合适的缓存服务器提供服务，选择的依据包括：用户的ip地址，判断哪台服务器距离用户最近，根据用户请求的url中携带的内容名称判断哪台服务器上有用户要的数据，查询各个服务器当前负载情况，判断哪台服务器有服务能力。基于这些条件综合分析后，区域负载均衡设备会向全局负载均衡设备请求返回一台缓存服务器的IP地址。全局负载均衡设备返回服务器IP地址，用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端，如果这台缓存服务器没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要像它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。域名解析服务器根据用户ip地址，把域名解析成相应节点的缓存服务器ip地址，实现用户就近访问，使用CDN服务的网站，只要将其域名解析权交给CDN的GSLB设备，将需要分发的内容注入到CDN就可以实现内容加速了。
DNS也是开销，通常浏览器查找一个给定域名的IP地址要花费20~120毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？

当客户端DNS缓存（浏览器和操作系统）缓存为空时，DNS查找的数量与要加载的Web页面中唯一主机名的数量相同，包括页面URL、脚本、样式表、图片、Flash对象等的主机名。减少主机名的 数量就可以减少DNS查找的数量。

DNS查询过程：
查看浏览器内部缓存
系统缓存：浏览器会调用一个类似 gethostbyname 的库函数，此函数会先去检测本地 hosts 文件，查看是否有对应 ip。
路由器缓存、ISP 缓存 如果浏览器和系统缓存都没有，系统的 gethostname 函数就会像 DNS 服务器发送请求。而网络服务一般都会先经过路由器以及网络服务商（电信），所以会先查询路由器缓存，然后再查询 ISP 的 DNS 缓存。
本地 DNS 服务器 通常为自己计算机搭建的小型 DNS 服务器，自我使用，属于 DNS 优化的一部分。
域名服务器 到此处的过程为：根域服务器（.） -> 顶级域名服务器（eg: .com，.org）-> 主域名服务器（eg: google.com） 如果域名正常，应该就会返回 IP 地址，如果没有浏览器就会提示找不到服务器地址。
浏览器获取到 IP 地址后，一般都会加到浏览器的缓存中，本地的 DNS 缓存服务器，也可以去记录。另外，一秒钟几千万的请求域名服务器如何满足？就是 DNS 负载均衡。
### 浏览器缓存的区别
web缓存分为：数据库缓存，服务端缓存（代理服务器缓存，CDN缓存）浏览器缓存
浏览器缓存包含很多内容：HTTP缓存（expires，Cache-Control，Etag..），cookie，localStorage等
缓存策略都是通过设置http的header来实现的
浏览器缓存主要是http协议定义的缓存机制，html  meta标签<meta HTTP_EQUIV="progrma" CONNET="no-store">让浏览器不缓存当前页面，但是代理服务器不解析html内容，一般应用广泛的是用http头信息控制缓存。

浏览器先根据这个资源的http头信息判断是否命中强缓存，如果命中强缓存，200，并且http响应中会要size：from cache
304是协商缓存，走强缓存就通过size：from cache识别
强缓存cache-control要max-age字段才命中强缓存
缓存机制： 先走强缓存，强缓存生效，返回200，并且从缓存中读取数据返回，强缓存失效，向服务端发起请求，协商缓存生效，返回304，继续使用缓存
浏览器缓存分为：
  强制缓存：
        expires:expires是服务器返回的资源过期时间，如果修改本地时间缓存会失效,expires是http1.0产物，是绝对时间
        cache-control:控制是否需要缓存，是http1.1产物，catch-control的优先级高于expires，是相对时间
  协商缓存：
    Etag/If-None-Match: 资源的标识符，资源变化，服务端的Etag就会发生变化，etag的优先级高于last-modified, 
    last-Modified/If-Modified-since:资源最后的修改时间，只能精确到秒，秒以内发生的变化感知不到,精度上Etag大于last-modified，性能上etag小于last-modified

Expires+Last-Modified+max-age+Etag 缺陷：max-age或者Expires不过期，浏览器无法感知文件变化，怎么让浏览器无法感知？ 
Http缓存改进： 1：md5/hash缓存 通过不缓存html，为静态文件添加MD5或hash标识，
             2：CDN缓存

缓存位置： 
  service-worker：自由控制缓存哪些文件，如何匹配和读取文件， 缓存是持续的
  Memory-cache： 读取速度快，缓存容量小，不是持续缓存，tab页关闭，缓存被释放
  Disk-cache： 读取速度慢，缓存容量大，缓存持续时间长。根据http的header判断哪些需要缓存，大部分缓存来自硬盘缓存
  push-cache: 只会在session会话中存在，会话关闭，缓存失效，推送缓存（http2.0),以上3种缓存没有命中才会使用，在chrome只有5分钟，不是严格根据http中header进行缓存

用户行为：地址栏输入：查找disk-cache是否有匹配，没有匹配发送请求
        普通刷新：F5,优先使用memory-cache,其次是disk-cache
        强制刷新： Ctrl+F5，不使用缓存

service-worker：运行在浏览器背后的独立线程，使用它必须用https，因为service-worker涉及到请求拦截，必须用https来保证安全。service-worker和浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件，如何匹配缓存，读取缓存，并且缓存是连续的。

### 请求报文
http请求过程中传递的数据快就是请求报文
报文头：客户端说的话
报文体：
请求报文头：
method,  version,  cookie,date, if-modified-since,if-nonematch, chartset,language,
响应报文头：
status，location,etag, date, set-cookie, length, last-modified,
### 状态码
100继续，客户端应该继续请求
101：切换协议，服务端根据客户端请求切换协议

201：已经创建，成功请求并创建了新的资源
202：已经接受，但是未处理完

301：永久重定向
302：临时重定向
303：see other查看其它地址
304：资源未修改
305：使用代理，请求的资源必须通过代理访问

400：客户端语法错误，服务器不理解
401：要求身份认证
402：保留，将来使用
403：服务端理解但是拒绝
404：页面丢失

500：服务器内部错误
501：服务器不支持请求的功能，无法完成请求
502：bad getWay作为网关或者代理的服务器尝试请求，收到了一个无效的响应

1：对内容解析，判断url还是内容
2：如果是url就查找本地缓存，expires（过期时间）和cache-control控制（no-store,max-age,no-cache），都没有就会发生请求进行协商缓存
在发生请求协商之前，会进行dns解析，具体：浏览器-》操作系统-》路由-》本地运行商-》根域名-》 本地-根域名（递归），根域名之间是迭代
拿到ip后就通过三次握手建立连接
  由客户端发起：SYN=1&seq=x，之后进入SYN_RECE状态
  服务器收到：SYN=1&seq=x+1，ack=y，进入
  客户端收到：ACK（ack=y，seq=x
连接建立之后，判断协商缓存是否生效，不生效，将资源返回
浏览器拿到响应内容：
上到下解析：遇到html标签生成html节点构成dom树
          css解析成cssom树
          将cssom树和dom树合并成render树
          计算布局，计算每个节点的大小尺寸位置
          绘制：将元素绘制到屏幕上
浏览器关闭tcp链接

如果浏览器在解析文档的时候，css不会阻塞dom树的构成，但是遇到script标签会阻塞
script放尾部，但是对于依赖js的项目来说不是很好

### SQL注入
 主要是针对数据库的，用户提交数据的SQL语句不安全 防御： 参数化查询：也叫预处理语句： 1：指定查询结构，用户输入预留占位符 2：指定占位符的内容
### XSS跨站脚本攻击，
将恶意代码植入到其他用户页面，其他用户在观看网页时候，恶意脚本就会执行。 比如做个假的登陆界面攻击成功后，攻击者可以得到私密网页内容和Cookie等  
XSS分类： 反射式XSS： 服务器未对用户提交的表单数据或者URL无害化处理，响应后浏览器解析执行XSS代码。这个过程像一次反射
         存储式XSS： 提交的代码会存储在服务器，永久性XSS，危害更大（容易留下痕迹被清除） 
         基于DOM的XSS攻击： DOM XSS的代码并不需要服务器参与，浏览器端的DOM解析触发xss
防御： 1：输入验证，对特殊字符进行处理，如"<“和”>"等进行转义。 2：输出编码，
### CSRF跨站请求伪造，也叫XSRF，f
攻击方式：如通过电子邮件发送一个链接来蛊惑受害者进行一些敏感性的操作，如修改密码，转账。用户登陆了A网站，因为某些原因访问了B网站（比如跳转等），B网站直接发送一个A网站的请求进行一些危险操作，由于A网站处于登陆状态，就发生了CSRF攻击（核心就是利用了cookie信息可以被跨站携带）！
CSRF攻击防御 1：增加一些确认操作，敏感操作时输入密码二次验证 3：使用Token
### http特点
1）支持客户/服务器模式（由客户端发出请求） 
2）简单快速，只要传送请求方法/路径（由于http协议简单，使得http服务器的程序规模小，因而通信速度很快 
3）灵活，http允许传输任意类型数据对象，由content-type加以标记（1.0后） 
4）无连接，每次连接只处理一个请求，服务器处理完客户端请求，并接收到客户端答应之后，就断开连接，采用这种方式可以节约时间。（keep-alive：让客户端与服务端的连接持续有效，避免重新建立连接） keep-alive就是将多个HTTP请求合并成一个 
5）无状态：协议对事务处理没有记忆能力，缺少状态意味着如果后续处理需要前面的信息，则它必须重传，导致每次传输数据很大
### SPDY
谷歌提出，为了最小化网络延迟，提升网络速度，对http的增强， 多路复用：允许一个连接可以有无限个并行请求，还可以设置优先级，防止非重要资源占用通道 2）支持服务器推送 3）spdy压缩了http的header，舍去了不必要的头部信息 4）强制使用SSL，网速变快
### http和https的区别
### https的证书颁发过程
### 对称加密和非对称加密
对称加密：加解密都用一个密钥，比如指纹解锁，登录要用同一个人的密码，常见对称加密算法：DES，3EDS，base64是对称加密，公钥就是base字符码表
非对称加密：主要是解决对称加密密钥传输问题，是一对公钥和私钥，github，ssh-keygen指定加密算法为rsa
hash和md5不算加密算法，是不可逆的，加密应该是可以还原的，非对称加密也不是绝对安全，存在交换公钥时公钥被篡改的问题。
### CDN
在浏览器本地缓存失效后，浏览器会像CDN边缘节点发起请求，类似浏览器缓存，通过http响应头中的cache-control设置CDN边缘节点数据缓存时间。 当浏览器向CDN节点请求数据时，会判断缓存是否过期，若过期，CDN会发出回源请求，拉取最新数据，更新本地缓存，优势： 1：访问延时大大降低,起到分流作用，减轻了源服务器的负载。
浏览器缓存的区别
web缓存：数据库缓存，服务端缓存（代理服务器缓存，CDN缓存）览器缓存：HTTP缓存（expires，Cache-Control，Etag.），cookie，localStorage等 缓存策略都是通过设置http的header来实现
缓存机制： 先走强缓存，expires（资源过期时间修改本地时间缓存失效http1.0产物），cache-control（http1.1产物，优先级高于expires） 协商缓存： Etag/If-None-Match: 资源的标识符，资源变化，服务端的Etag就会发生变化，etag的优先级高于last-modified, last-Modified:资源最后的修改时间，只能精确到秒，秒以内发生的变化感知不到,精度上Etag大于last-modified，性能上etag小于last-modified
Expires+Last-Modified+max-age+Etag 缺陷：max-age或者Expires不过期，浏览器无法感知文件变化，怎么让浏览器无法感知？ Http缓存改进： 1：md5/hash缓存 通过不缓存html，为静态文件添加MD5或hash标识， 2：CDN缓存
缓存位置： service-worker：自由控制缓存哪些文件，如何匹配和读取文件， 缓存是持续的 Memory-cache： 读取速度快，缓存容量小，不是持续缓存，tab页关闭，缓存被释放 Disk-cache： 读取速度慢，容量大，缓存时间长。根据http的header判断哪些需要缓存，大部分缓存来自硬盘缓存 push-cache: 只会在session会话中存在，会话关闭，缓存失效，推送缓存（http2.0),以上3种缓存没有命中才会使用，在chrome只有5分钟，不是严格根据http